# -*- coding: utf-8 -*-

import pytest
import datetime as dt
import cal


def test_cal():
    """
        test cases:
        - n = 19
        - 0 < dds <= 6 e 28 <= n <= 31
        (invalid cases are discarded by the main, as both parameters
         are generated by the first_of_month and number_of_days methods, which are already being tested)
    """
    expected_result_1 = "       1  2 14 15 16\n17 18 19 20 21 22 23\n24 25 26 27 28 29 30"
    expected_result_2 = "          1  2  3  4\n 5  6  7  8  9 10 11\n12 13 14 15 16 17 18\n19 20 21 22 23 24 25\n26 27 28 29 30 "

    assert cal.cal(2, 19) == expected_result_1
    assert cal.cal(3, 30) == expected_result_2


@pytest.mark.parametrize('input, expected_result', [
    (4, True),     # Year less than 1752 and multiple of 4
    (1501, False), # Year less than 1752 and non-multiple of 4
    (1900, False), # Year greater than 1752 and multiple of 100
    (1903, False), # Year greater than 1752 and not a multiple of 4
    (1904, True),  # Year greater than 1752 and multiple of 4
    (2000, True),  # Year greater than 1752 and multiple of 400
    (1700, True)
])
def test_is_leap(input, expected_result):
    actual = cal.is_leap(input)
    assert actual == expected_result


@pytest.mark.skipif(True, reason='simply ignoring for now')
def test_mutation_is_leap():
    assert cal.is_leap(1752) is True


@pytest.mark.parametrize('input, expected_result', [
    ((1, 1), 6),      # Non-leap year
    ((1, 4), 2),      # Leap year, month <= 2
    ((5, 4), 4),      # Leap year, month > 2
    ((9, 1752), 2),   # Year 1752, month <= 9
    ((11, 1752), 3),  # Year 1752, month > 9
])
def test_first_of_month(input, expected_result):
    month, year = input
    actual = cal.first_of_month(month, year)
    assert actual == expected_result


@pytest.mark.parametrize('input, expected_result', [
    (1801, 4), # Year greater than 1800 (expected: Thursday, 4)
    (1780, 6), # Year < 1800 and > 1752 (expected: Saturday, 6)
    (1500, 3), # Year less than 1752 (expected: Wednesday, 3)
])
def test_jan1(input, expected_result):
    actual = cal.jan1(input)
    assert actual == expected_result


@pytest.mark.parametrize('input, expected_result', [
    ((3, 2001), 31),   # Non-leap year
    ((2, 2000), 29),   # Leap year, month <= 2
    ((3, 2000), 31),   # Leap year, month > 2
    ((9, 1752), 19),   # Year 1752, month <= 9
    ((12, 1752), 31),  # Year 1752, month > 9
])
def test_number_of_days(input, expected_result):
    month, year = input
    actual = cal.number_of_days(month, year)
    assert actual == expected_result


# ------------------------
# Novos testes (para matar sobreviventes)
# ------------------------

def _dow_sun0(y: int, m: int, d: int = 1) -> int:
    """
    Converte datetime.weekday() (Mon=0..Sun=6) para convenção usada no cal (Sun=0..Sat=6).
    Válido para anos Gregorianos.
    """
    return (dt.date(y, m, d).weekday() + 1) % 7


def test_first_of_month_leap_boundary_2000():
    # Mata off-by-one em ano bissexto (month >= 2 / > 3)
    assert cal.first_of_month(2, 2000) == _dow_sun0(2000, 2)  # fevereiro/2000
    assert cal.first_of_month(3, 2000) == _dow_sun0(2000, 3)  # março/2000


def test_first_of_month_january_non_leap_2001():
    # Garante que janeiro entra no somatório (mata range(1, month) se aplicável)
    assert cal.first_of_month(1, 2001) == _dow_sun0(2001, 1)


def test_is_leap_boundaries_1752_1753():
    # Força fronteiras do bloco juliano/gregoriano
    assert cal.is_leap(1752) is True   # juliano
    assert cal.is_leap(1753) is False  # gregoriano


def test_jan1_neighbor_years_properties():
    # 1800 não é bissexto (século não múltiplo de 400)
    assert cal.jan1(1801) == (cal.jan1(1800) + 1) % 7
    # 2000 é bissexto (múltiplo de 400)
    assert cal.jan1(2001) == (cal.jan1(2000) + 2) % 7


def test_jan1_transition_1752_to_1753():
    # 1752 (juliano) -> 1753 (gregoriano) aplica +3 além do incremento anual;
    # como 1752 é bissexto, total = +2 (bissexto) + 3 (ajuste) = +5
    assert cal.jan1(1753) == (cal.jan1(1752) + 5) % 7


def test_first_of_month_1752_october_transition():
    # Após setembro/1752 há correção de 11 dias (regra do próprio cal.py).
    # A relação correta é: dds(out/1752) == (dds(set/1752) + number_of_days(set/1752)) % 7
    assert cal.first_of_month(10, 1752) == (
        cal.first_of_month(9, 1752) + cal.number_of_days(9, 1752)
    ) % 7


@pytest.mark.parametrize("y", [1800, 1801, 1900, 2000, 2001])
def test_jan1_matches_datetime_gregorian(y):
    # jan1 deve bater com o calendário gregoriano do datetime para anos comuns no proleptico
    assert cal.jan1(y) == _dow_sun0(y, 1, 1)

@pytest.mark.parametrize("y", [1836, 1902])
def test_jan1_specific_years_kill_19_20(y):
    # Estes anos garantem que o valor correto (gregoriano prolepítico) difere dos mutantes _19/_20
    assert cal.jan1(y) == _dow_sun0(y, 1, 1)